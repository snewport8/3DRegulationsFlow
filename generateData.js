const fs = require('fs');
const path = require('path');

// --- Configuration ---
const flowCsvPath = path.join(__dirname, '..', 'flow.csv');
const outcomesCsvPath = path.join(__dirname, '..', 'outcomes.csv');
const flowOutputPath = path.join(__dirname, '..', 'data', 'flowData.ts');
const outcomesOutputPath = path.join(__dirname, '..', 'data', 'outcomes.ts');

/**
 * A simple CSV parser.
 * This is a basic implementation and may not handle all edge cases,
 * such as newlines within quoted fields.
 * @param {string} csvString The entire CSV content as a string.
 * @returns {string[][]} A 2D array of strings representing the parsed data.
 */
function parseCsv(csvString) {
  // Remove BOM if it exists
  const cleanedString = csvString.charCodeAt(0) === 0xFEFF ? csvString.substring(1) : csvString;
  const lines = cleanedString.trim().split('\n');
  return lines.map(line => 
    line.split(',').map(field => field.trim().replace(/^"|"$/g, ''))
  );
}

function processFlowData() {
  const csvData = fs.readFileSync(flowCsvPath, 'utf8');
  const [header, ...rows] = parseCsv(csvData);

  const colIndices = header.reduce((acc, col, index) => {
    acc[col.trim()] = index;
    return acc;
  }, {});

  const flowData = {};
  rows.forEach((row, index) => {
    const id = row[colIndices['ID']];
    if (!id) {
      console.warn(`Skipping empty row at line ${index + 2} of flow.csv.`);
      return;
    }

    const type = row[colIndices['Type']];
    const text = row[colIndices['Question/Text']];
    const yesNextId = row[colIndices['Yes_Next_ID']];
    const noNextId = row[colIndices['No_Next_ID']];
    const continueId = row[colIndices['Continue']];
    const actionResult = row[colIndices['ActionResult']];

    const placeholderText = `This is ${type.toLowerCase()} step ${id}.`;

    const step = {
      id,
      type,
      text: text || placeholderText,
    };

    if (yesNextId) step.yesNextId = yesNextId;
    if (noNextId) step.noNextId = noNextId;
    if (continueId) step.continueId = continueId;
    if (actionResult) step.actionResult = actionResult;

    flowData[id] = step;
  });

  const fileContent = `
import type { FlowStep } from '../types';
import { FlowStepType } from '../types';

// This file is auto-generated by scripts/generateData.js
// Do not edit this file directly. Instead, edit flow.csv and run the script.

export const flowData: Record<string, FlowStep> = ${JSON.stringify(flowData, null, 2)};
`.trim();

  const finalContent = fileContent.replace(/"type": "(Question|Info|End)"/g, '"type": FlowStepType.$1');
  fs.writeFileSync(flowOutputPath, finalContent + '\n', 'utf8');
  console.log(`✅ Successfully generated data/flowData.ts from ${rows.length} rows in flow.csv`);
}

function processOutcomesData() {
  const csvData = fs.readFileSync(outcomesCsvPath, 'utf8');
  const [header, ...rows] = parseCsv(csvData);

  const colIndices = header.reduce((acc, col, index) => {
    acc[col.trim()] = index;
    return acc;
  }, {});
  
  const outcomesData = {};
  rows.forEach((row, index) => {
    const id = row[colIndices['ID']];
    if (!id) {
      console.warn(`Skipping empty row at line ${index + 2} of outcomes.csv.`);
      return;
    }
    outcomesData[id] = {
      id: id,
      title: row[colIndices['Title']],
      description: row[colIndices['Description']],
    };
  });

  const fileContent = `
import type { Outcome } from '../types';

// This file is auto-generated by scripts/generateData.js
// Do not edit this file directly. Instead, edit outcomes.csv and run the script.

export const outcomes: Record<string, Outcome> = ${JSON.stringify(outcomesData, null, 2)};
`.trim();

  fs.writeFileSync(outcomesOutputPath, fileContent + '\n', 'utf8');
  console.log(`✅ Successfully generated data/outcomes.ts from ${rows.length} rows in outcomes.csv`);
}

// --- Main Script Logic ---
try {
  processFlowData();
  processOutcomesData();
} catch (error) {
  console.error('❌ An error occurred while generating data:', error);
  process.exit(1);
}
